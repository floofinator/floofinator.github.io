<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> - Luke Thomson - Floofinator</title>

    <!-- Open Graph Protocal for social media embed -->
    <meta property="og:title" content="">
    <meta property="og:site_name" content="Floofinator.com">
    <meta property="og:description" content="The website of Floofinator">
    <meta property="og:image" content="/media/background.jpg" />
    <meta property="og:image:secure_url" content="/media/background.jpg" />
    <meta property="og:url" content="https://floofinator.com/games/FPS/FPSGame/">
    <meta property="og:image:type" content="website" />
    <meta property="og:image:alt" content="Thumbnail" />

    <link rel="stylesheet" href="/style.css">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Tilt+Warp&family=Varela+Round&display=swap"
        rel="stylesheet">
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/"
            }
        }
    </script>
    <script defer src="/js/sticky.js"></script>
    <script defer src="/js/show.js"></script>
    <script defer type="module" src="/js/background.js"></script>
</head>

<body>
    <div id="center-frame">
        <header>
            <h1>Floofinator</h1>
            <h2>Luke Thomson</h2>
        </header>
        <div id="content-frame">
            <nav>
                <div id="sticky">
                    <a href="/index.html">Index</a>
                    
                    
                        <a href="/about/">About</a>
                    
                    
                    
                        <a href="/art/">Art</a>
                    
                    
                    
                        <a href="/games/" class="current">Games</a>
                    
                    
                </div>
            </nav>
            <main>
                <h1>Title</h1>
                <hr>
                <!DOCTYPE HTML>
<HTML lang="en">

<Head>
	<Title>"Game Engine"</TITLE>

	<script id="floorOBJ" type="notjs">
		# Blender 3.3.5
		# www.blender.org
		o Plane
		v -500.000000 0.000000 500.000000
		v 500.000000 0.000000 500.000000
		v -500.000000 0.000000 -500.000000
		v 500.000000 0.000000 -500.000000
		vn -0.0000 1.0000 -0.0000
		vt 0.000000 0.000000
		vt 1.000000 0.000000
		vt 0.000000 1.000000
		vt 1.000000 1.000000
		s 0
		f 2/2/1 3/3/1 1/1/1
		f 2/2/1 4/4/1 3/3/1
	</script>

	<script id="cubeOBJ" type="notjs">
		# Blender 3.3.5
		# www.blender.org
		o Cube
		v 1.000000 1.000000 -1.000000
		v 1.000000 -1.000000 -1.000000
		v 1.000000 1.000000 1.000000
		v 1.000000 -1.000000 1.000000
		v -1.000000 1.000000 -1.000000
		v -1.000000 -1.000000 -1.000000
		v -1.000000 1.000000 1.000000
		v -1.000000 -1.000000 1.000000
		vn -0.0000 1.0000 -0.0000
		vn -0.0000 -0.0000 1.0000
		vn -1.0000 -0.0000 -0.0000
		vn -0.0000 -1.0000 -0.0000
		vn 1.0000 -0.0000 -0.0000
		vn -0.0000 -0.0000 -1.0000
		vt 0.500000 0.500000
		vt 0.500000 1.000000
		vt 0.000000 0.500000
		vt 1.000000 0.000000
		vt 0.000000 1.000000
		vt 0.500000 0.500000
		vt 0.500000 1.000000
		vt 0.000000 0.500000
		vt 1.000000 0.500000
		vt 0.000000 1.000000
		vt 1.000000 0.500000
		vt 0.500000 1.000000
		vt 0.500000 0.500000
		vt 0.500000 0.000000
		vt 0.000000 0.500000
		vt 0.000000 1.000000
		vt 1.000000 1.000000
		vt 0.500000 1.000000
		vt 0.500000 0.500000
		vt 0.000000 0.500000
		vt 0.000000 1.000000
		vt 0.500000 0.500000
		s 0
		f 5/11/1 3/7/1 1/1/1
		f 3/6/2 8/21/2 4/8/2
		f 7/19/3 6/16/3 8/20/3
		f 2/4/4 8/22/4 6/14/4
		f 1/1/5 4/10/5 2/3/5
		f 5/13/6 2/5/6 6/15/6
		f 5/11/1 7/17/1 3/7/1
		f 3/6/2 7/18/2 8/21/2
		f 7/19/3 5/12/3 6/16/3
		f 2/4/4 4/9/4 8/22/4
		f 1/1/5 3/7/5 4/10/5
		f 5/13/6 1/2/6 2/5/6
	</script>

	<script id="2dVertexShader" type="notjs">
		precision mediump float;

		attribute vec4 a_position;
		attribute vec3 a_color;
		attribute vec2 a_texCoord;
		attribute vec4 a_normal;

		varying vec3 v_color;
		varying vec2 v_texCoord;
		varying vec3 v_normal;
		varying vec3 v_worldPosition;
		varying vec4 v_clipPosition;

		uniform vec3 u_cameraTran;
		uniform vec3 u_cameraRot;

		uniform float u_viewAspect;
		uniform float u_viewFOV;
		uniform float u_viewNear;
		uniform float u_viewFar;

		uniform vec3 u_translation;
		uniform vec3 u_rotation;
		uniform vec3 u_scale;

		vec4 MoveCamera(vec4 pos)
		{
			vec3 cos = cos(u_cameraRot);
			vec3 sin = sin(u_cameraRot);

			mat4 translateView = mat4(
				1.0,0.0,0.0,0.0,
				0.0,1.0,0.0,0.0,
				0.0,0.0,-1.0,0.0,
				-u_cameraTran.x,-u_cameraTran.y,u_cameraTran.z,1.0
			);

			mat4 rX = mat4( 
				1.0,  0.0,  0.0,  0.0,
				0.0,  cos.x,sin.x,0.0,
				0.0, -sin.x,cos.x,0.0,
				0.0,  0.0,  0.0,  1.0
			);

			mat4 rY = mat4( 
				cos.y,0.0, -sin.y,0.0,
				0.0,  1.0,  0.0,  0.0,
				sin.y,0.0,  cos.y,0.0,
				0.0,  0.0,  0.0,  1.0
			);

			mat4 rZ = mat4( 
				cos.z,sin.z,0.0,  0.0,
				-sin.z,cos.z,0.0,  0.0,
				0.0,  0.0,  1.0,  0.0,
				0.0,  0.0,  0.0,  1.0
			);

			return rZ * rY * rX * translateView * pos;
		}

		vec4 ApplyProjection(vec4 pos)
		{
			float yScale = 1.0 / tan(radians(u_viewFOV) / 2.0);
			float xScale = yScale / u_viewAspect;
			float Dif = u_viewFar-u_viewNear;
			mat4 perspectiveMatrix = mat4(
				xScale, 0.0,      0.0,                             0.0,
				0.0,    yScale,   0.0,                             0.0,
				0.0,    0.0,      -1.0*(u_viewFar+u_viewNear)/Dif, -1.0,
				0.0,    0.0,      -2.0*u_viewFar*u_viewNear/Dif,   0.0
			);

			return perspectiveMatrix * pos;
		}

		vec4 ScaleObject(vec4 pos)
		{
			if(length(u_scale) != 0.0)
			{
				mat4 scaleM = mat4(
					u_scale.x,0.0,0.0,0.0,
					0.0,u_scale.y,0.0,0.0,
					0.0,0.0,u_scale.z,0.0,
					0.0,0.0,0.0,1.0
				);
				return scaleM*pos;
			}
			else
			{
				return pos;
			}
		}

		vec4 RotateObject(vec4 pos)
		{
			vec3 cos = cos(u_rotation);
			vec3 sin = sin(u_rotation);

			mat4 rX = mat4( 
				1.0,  0.0,  0.0,  0.0,
				0.0,  cos.x,sin.x,0.0,
				0.0, -sin.x,cos.x,0.0,
				0.0,  0.0,  0.0,  1.0
			);

			mat4 rY = mat4( 
				cos.y,0.0, -sin.y,0.0,
				0.0,  1.0,  0.0,  0.0,
				sin.y,0.0,  cos.y,0.0,
				0.0,  0.0,  0.0,  1.0
			);

			mat4 rZ = mat4( 
				cos.z,sin.z,0.0,  0.0,
				-sin.z,cos.z,0.0,  0.0,
				0.0,  0.0,  1.0,  0.0,
				0.0,  0.0,  0.0,  1.0
			);

			return rZ * rY * rX * pos;
		}

		vec4 PositionObject(vec4 pos)
		{
			mat4 translateM = mat4(
				1.0,0.0,0.0,0.0,
				0.0,1.0,0.0,0.0,
				0.0,0.0,1.0,0.0,
				u_translation.x,u_translation.y,u_translation.z,1.0
			);
			return translateM*pos;
		}

		void main()
		{
			v_color = a_color;

			vec4 worldPos = PositionObject(RotateObject(ScaleObject(a_position)));

			vec4 cameraSpace = MoveCamera(worldPos);
			
			v_color = a_color;
			v_texCoord = a_texCoord;
			v_normal = normalize(RotateObject(ScaleObject(a_normal)).xyz);

			v_clipPosition = ApplyProjection(cameraSpace);
			
			gl_Position = v_clipPosition;

			v_worldPosition = worldPos.xyz;
		}		
	</SCRIPT>

	<script id="2dFragmentShader" type="notjs">
		//Fragment shaders do not have precision so we have to set it.
		precision mediump float;

		varying vec3 v_color;
		varying vec2 v_texCoord;
		varying vec3 v_normal;
		varying vec3 v_worldPosition;
		varying vec4 v_clipPosition;

		uniform vec3 u_lightPos[16];
		uniform vec3 u_lightColor[16];
		uniform vec3 u_lightDir[16];

		uniform int u_lightType[16];

		uniform float u_lightRange[16];
		uniform float u_lightAngle[16];
		
		uniform vec3 u_mainLightDir;
		uniform vec3 u_mainLightColor;
		uniform vec3 u_ambientLightColor;
		
		uniform vec3 u_fogColor;
		uniform float u_fogStrength;

		uniform float u_lightStrength;
		uniform vec4 u_color;

		uniform vec2 u_uvScale;
		uniform vec2 u_uvOffset;
		uniform sampler2D u_texture;
		
		uniform float u_viewFar;

		uniform float u_clipThreshold;

		vec3 pointLightStrength(vec3 lightPosition, float range, vec3 color, vec3 position, vec3 normal)
		{
			if(range == 0.0) return vec3(0,0,0);
			vec3 difference = lightPosition - position;
			float distance = length(difference);
			float distanceStrength = clamp(1.0 - (distance / range),0.0,1.0);

			vec3 lightDirection = normalize(difference);
			float dotProd = dot(lightDirection,normal);
			float normalStrength = clamp(dotProd,0.0,1.0);

			return color * distanceStrength * normalStrength;
		}

		vec3 spotLightStrength(vec3 lightPosition, float range, vec3 color, vec3 lightForward, float angle, vec3 position, vec3 normal)
		{
			if(range == 0.0) return vec3(0,0,0);
			vec3 difference = lightPosition - position;
			float distance = length(difference);
			float distanceStrength = 1.0 - clamp((distance / range),0.0,1.0);

			vec3 lightDirection = normalize(difference);
			float directionDot = dot(lightDirection,-normalize(lightForward));
			float directionStrength = 1.0 - pow(clamp(acos(directionDot) / radians(angle),0.0,1.0),1.5);

			float normalDotProd = dot(lightDirection,normal);
			float normalStrength = clamp(normalDotProd,0.0,1.0);

			return color * distanceStrength * normalStrength * directionStrength;
		}

		vec3 pointLightTotal(vec3 position, vec3 normal)
		{
			vec3 sum = vec3(0,0,0);
			for(int i = 0; i < 16; i++)
			{
				if(u_lightType[i] == 0)
				{
					sum += pointLightStrength(u_lightPos[i], u_lightRange[i], u_lightColor[i], position, normal);
				}
				else
				{
					sum += spotLightStrength(u_lightPos[i], u_lightRange[i], u_lightColor[i], u_lightDir[i], u_lightAngle[i], position, normal);
				}
			}
			return sum;
		}

		void main()
		{
			vec3 normal = normalize(v_normal);

			float dotProd = dot(normal,normalize(u_mainLightDir));
			float mainLightStrength = clamp(dotProd,0.0,1.0);
			vec3 mainLight = mainLightStrength * u_mainLightColor;

			vec3 pointLight = pointLightTotal(v_worldPosition,normal);

			vec3 light = pointLight + mainLight + u_ambientLightColor;

			float fogStrength = (v_clipPosition.z/u_viewFar);
			float fogEnd = 1.0-(32.0/u_viewFar);
			fogStrength = clamp(pow(fogStrength + fogEnd,8.0)/4.0,0.0,1.0);
			
			vec2 scaledTexCoord = v_texCoord * u_uvScale;
			vec2 offsetTexCoord = scaledTexCoord + u_uvOffset;
			vec4 textureColor = texture2D(u_texture,offsetTexCoord);
			
			vec4 surfaceColor = u_color * vec4(v_color,1) * textureColor;
			
			vec4 litColor = surfaceColor * vec4(light,1);
			
			vec4 litFinal = mix(surfaceColor,litColor,u_lightStrength);
			
			vec4 finalColor = mix(litFinal,vec4(u_fogColor,surfaceColor.a), fogStrength * u_fogStrength);
			
			if(finalColor.a < 1.0-u_clipThreshold)
			{
				discard;
			}
			
			vec4 gammaCorrected = pow(finalColor,vec4(1,1,1,1));
			
			gl_FragColor = gammaCorrected;

			//gl_FragColor = textureColor;
		}
	</script>

	<script>
		class Transform {
			constructor() {
				this.loc = [0, 0, 0];
				this.rot = [0, 0, 0];
				this.scale = [1, 1, 1];

				this.forward = [0, 0, 1];
				this.right = [1, 0, 0];
				this.up = [0, 1, 0];
			}

			setLocation(loc) {
				this.loc = [...loc];
			}

			setRotation(rot) {
				this.rot = [...rot]
				//this.rot = [rot.x%360,rot.y%360,rot.z%360];
				this.updateMatrices(this.rot);
				//this.forward = this.crossMultiply(xRot,[0,0,1,0]);		
				this.forward = this.crossMultiply(this.zRot, this.crossMultiply(this.yRot, this.crossMultiply(this.xRot, [0, 0, 1, 0])))
				this.right = this.crossMultiply(this.zRot, this.crossMultiply(this.yRot, this.crossMultiply(this.xRot, [1, 0, 0, 0])))
				this.up = this.crossMultiply(this.zRot, this.crossMultiply(this.yRot, this.crossMultiply(this.xRot, [0, 1, 0, 0])))
			}
			updateMatrices(rot) {
				this.xRot = [
					[1, 0, 0, 0],
					[0, Math.cos(rot[0]), -1 * Math.sin(rot[0]), 0],
					[0, Math.sin(rot[0]), Math.cos(rot[0]), 0],
					[0, 0, 0, 1]
				];
				this.yRot = [
					[Math.cos(rot[1]), 0, Math.sin(rot[1]), 0],
					[0, 1, 0, 0],
					[-1 * Math.sin(rot[1]), 0, Math.cos(rot[1]), 0],
					[0, 0, 0, 1]
				];
				this.zRot = [
					[Math.cos(rot[2]), -1 * Math.sin(rot[2]), 0, 0],
					[Math.sin(rot[2]), Math.cos(rot[2]), 0, 0],
					[0, 0, 1, 0],
					[0, 0, 0, 1]
				]
			}

			crossMultiply(M, V) {
				var temp = [
					M[0][0] * V[0] + M[0][1] * V[1] + M[0][2] * V[2] + M[0][3] * V[3],
					M[1][0] * V[0] + M[1][1] * V[1] + M[1][2] * V[2] + M[1][3] * V[3],
					M[2][0] * V[0] + M[2][1] * V[1] + M[2][2] * V[2] + M[2][3] * V[3],
					M[3][0] * V[0] + M[3][1] * V[1] + M[3][2] * V[2] + M[3][3] * V[3]
				]
				return temp;
			}

			Multiply3x3(M1, M2) {
				var temp = [
					M1[0][0] * M2[1][0] + M1[1][0] * M2[1][1] + M1[2][0] * M2[1][2],
					M1[0][0] * M2[0][0] + M1[1][0] * M2[0][1] + M1[2][0] * M2[0][2],
					M1[0][0] * M2[2][0] + M1[1][0] * M2[2][1] + M1[2][0] * M2[2][2],

					M1[0][1] * M2[0][0] + M1[1][1] * M2[0][1] + M1[2][1] * M2[0][2],
					M1[0][1] * M2[1][0] + M1[1][1] * M2[1][1] + M1[2][1] * M2[1][2],
					M1[0][1] * M2[2][0] + M1[1][1] * M2[2][1] + M1[2][1] * M2[2][2],

					M1[0][2] * M2[0][0] + M1[1][2] * M2[0][1] + M1[2][2] * M2[0][2],
					M1[0][2] * M2[1][0] + M1[1][2] * M2[1][1] + M1[2][2] * M2[1][2],
					M1[0][2] * M2[2][0] + M1[1][2] * M2[2][1] + M1[2][2] * M2[2][2]
				]
				return temp;
			}

		}

		class OBJ {
			static Import(obj) {
				const lines = obj.replace(/\t/g, '').split(/\r?\n/g).filter(n => n != '');
				const statements = []
				for (const line of lines) {
					const words = line.split(/\t? /);
					statements.push(words);
				}

				const verts = []
				const vertTextures = []
				const vertNormals = []
				const vertColors = []
				var vertData = []

				for (const statement of statements) {
					const statementType = statement[0]

					switch (statementType) {
						case "v":
							verts.push([
								Number(statement[1]),
								Number(statement[2]),
								Number(statement[3])
							])

							if (statement.length > 4) {
								vertColors.push([
									Number(statement[4]),
									Number(statement[5]),
									Number(statement[6])
								])
							}

							break;

						case "vt":
							vertTextures.push([
								Number(statement[1]),
								Number(statement[2]),
								0
							])
							break;

						case "vn":
							vertNormals.push([
								Number(statement[1]),
								Number(statement[2]),
								Number(statement[3])
							])
							break;

						case "f":
							for (let i = 1; i < 4; i++) {
								const face = statement[i];
								const indices = face.split('/');

								const vertIndex = Number(indices[0]) - 1;
								const textureIndex = Number(indices[1]) - 1;
								const normalIndex = Number(indices[2]) - 1;

								const vertices = verts[vertIndex]

								var vertexColors = [1, 1, 1]
								if (vertColors.length > 0) vertexColors = vertColors[vertIndex]

								const vertexTexture = vertTextures[textureIndex]
								const vertexNormal = vertNormals[normalIndex]

								vertData = vertData.concat(vertices);
								vertData = vertData.concat(vertexColors);
								vertData = vertData.concat(vertexTexture);
								vertData = vertData.concat(vertexNormal);
							}
							break;

						default:
							break;
					}
				}

				return vertData
			}
		}

		class GameObject {
			constructor() {
				this.transform = new Transform();
				this.collisionShape = null;
				this.renderShape = null;

				this.velocity = [0, 0, 0];
				this.angVelocity = [0, 0, 0];

				this.name = "Default";
				this.id = 0;

				this.className;
			}

			update(delta, time) {
				this.transform.setLocation(VMath.add(this.transform.loc, VMath.multiply(this.velocity, delta)));
				this.transform.setRotation(VMath.add(this.transform.rot, VMath.multiply(this.angVelocity, delta)));
			}
		}

		class Render {
			constructor(gameobject) {
				this.gameobject = gameobject;
				this.color = [1, 1, 1, 1];
			}
			render(program) {

			}
		}

		var TEXTURES = []

		class RenderShape extends Render {
			constructor(gameobject) {
				super(gameobject);

				this.buffer = gl.createBuffer();

				this.fogStrength = 1;
				this.lightStrength = 1;
				this.transparent = false;

				this.uvOffset = [0, 0]
				this.uvScale = [1, 1]

				this.clipThreshold = 1;

				this.vertData = [];

				this.texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, this.texture);

				// Fill the texture with a 1x1 white pixel.
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
			}
			loadTexture(source) {
				// Asynchronously load an image


				if (TEXTURES[source]) {
					this.texture = TEXTURES[source];
				}
				else {
					console.log(`Adding textue ${source}`)
					var texture = this.texture;
					TEXTURES[source] = texture;
					var image = new Image()
					image.crossOrigin = 'anonymous'
					image.src = source
					image.addEventListener('load', function () {
						// Now that the image has loaded make copy it to the texture.
						gl.bindTexture(gl.TEXTURE_2D, texture);
						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
						gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
						gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
						gl.generateMipmap(gl.TEXTURE_2D);

					});
				}

			}
			fromOBJ(obj) {
				const objData = OBJ.Import(obj);
				this.bufferVertData(objData)
			}
			bufferVertData(vertData) {
				this.vertData = vertData;
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertData), gl.STATIC_DRAW);
			}
			render(program) {
				var loc = this.gameobject.transform.loc;
				var rot = this.gameobject.transform.rot;
				var scale = this.gameobject.transform.scale;

				//Texture
				gl.bindTexture(gl.TEXTURE_2D, this.texture);

				//Position
				gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
				var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
				var size = 3;
				var type = gl.FLOAT;
				var normalize = false;
				var stride = 12 * Float32Array.BYTES_PER_ELEMENT;
				var offset = 0;        // start at the beginning of the buffer
				gl.enableVertexAttribArray(positionAttributeLocation);
				gl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);

				//Color
				var colorAttributeLocation = gl.getAttribLocation(program, "a_color");
				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 12 * Float32Array.BYTES_PER_ELEMENT;
				offset = 3 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(colorAttributeLocation);
				gl.vertexAttribPointer(colorAttributeLocation, size, type, normalize, stride, offset);

				//Texture
				var textureAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 12 * Float32Array.BYTES_PER_ELEMENT;
				offset = 6 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(textureAttributeLocation);
				gl.vertexAttribPointer(textureAttributeLocation, size, type, normalize, stride, offset);

				//Normal
				var normalAttributeLocation = gl.getAttribLocation(program, "a_normal");
				size = 3;
				type = gl.FLOAT;
				normalize = false;
				stride = 12 * Float32Array.BYTES_PER_ELEMENT;
				offset = 9 * Float32Array.BYTES_PER_ELEMENT;
				gl.enableVertexAttribArray(normalAttributeLocation);
				gl.vertexAttribPointer(normalAttributeLocation, size, type, normalize, stride, offset);

				var tranLoc = gl.getUniformLocation(program, 'u_translation');
				gl.uniform3fv(tranLoc, new Float32Array(loc));
				var thetaLoc = gl.getUniformLocation(program, 'u_rotation');
				gl.uniform3fv(thetaLoc, new Float32Array(rot));
				var scaleLoc = gl.getUniformLocation(program, 'u_scale');
				gl.uniform3fv(scaleLoc, new Float32Array(scale));

				var colorLoc = gl.getUniformLocation(program, 'u_color');
				gl.uniform4fv(colorLoc, new Float32Array(this.color));

				var lightStrengthLoc = gl.getUniformLocation(program, 'u_lightStrength');
				gl.uniform1f(lightStrengthLoc, this.lightStrength);

				var fogStrengthLoc = gl.getUniformLocation(program, 'u_fogStrength');
				gl.uniform1f(fogStrengthLoc, this.fogStrength);

				var clipThresholdLoc = gl.getUniformLocation(program, 'u_clipThreshold');
				gl.uniform1f(clipThresholdLoc, this.clipThreshold);

				var uvScaleLoc = gl.getUniformLocation(program, 'u_uvScale');
				gl.uniform2fv(uvScaleLoc, new Float32Array(this.uvScale));
				var uvOffsetLoc = gl.getUniformLocation(program, 'u_uvOffset');
				gl.uniform2fv(uvOffsetLoc, new Float32Array(this.uvOffset));

				var primitiveType = gl.TRIANGLES;
				offset = 0;
				gl.drawArrays(primitiveType, offset, this.vertData.length / 6);
			}
		}

		class RenderBillboard extends RenderShape {
			constructor(gameobject) {
				super(gameobject);

				var billboardVertData = [
					-1, -1, 0, 1, 1, 1, 0, 0, 0, 0, 0, -1,
					-1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, -1,
					1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, -1,

					-1, -1, 0, 1, 1, 1, 0, 0, 0, 0, 0, -1,
					1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, -1,
					1, -1, 0, 1, 1, 1, 1, 0, 0, 0, 0, -1,
				]

				this.bufferVertData(billboardVertData);
				this.clipThreshold = 0.5;
			}

			render(program) {
				this.gameobject.transform.rot = mainInstance.player.camera.transform.rot;
				super.render(program);
			}
		}
		class AnimatedBillboard extends RenderBillboard {
			constructor(gameobject) {
				super(gameobject);

				this.frameRowCol = [1, 1];
				this.frame = 0;
			}
			render(program) {
				this.uvScale = [1 / this.frameRowCol[0], 1 / this.frameRowCol[1]]

				var xOffset = Math.floor(this.frame % this.frameRowCol[0]) / this.frameRowCol[0]
				var yOffset = Math.floor(this.frame / this.frameRowCol[1]) / this.frameRowCol[1]

				console.log(yOffset);

				this.uvOffset = [xOffset, 1 - yOffset - this.uvScale[1]]
				super.render(program);
			}
		}

		class CollisionShape {
			constructor(gameobject) {
				this.gameobject = gameobject;
			}
			getDistance(point) { }
			getNormal(point) { }
		}

		class CollisionSphere extends CollisionShape {
			constructor(gameobject, radius) {
				super(gameobject);
				this.radius = radius;
			}
			getDistance(point) {
				var center = this.gameobject.transform.loc;
				var scale = this.gameobject.transform.scale;

				return this.radius * scale[0];
			}
			getNormal(point) {
				var center = this.gameobject.transform.loc;

				var dif = VMath.subtract(point, center);
				return VMath.normalize(dif);
			}
		}

		class CollisionCube extends CollisionShape {
			constructor(gameobject, width, height, depth) {
				super(gameobject);
				this.width = width;
				this.height = height;
				this.depth = depth;
			}
			getDistance(point) {
				var center = this.gameobject.transform.loc;
				var test = [...point];

				if (test[0] < center[0] - this.width / 2)
					test[0] = center[0] - this.width / 2;
				else if (test[0] > center[0] + this.width / 2)
					test[0] = center[0] + this.width / 2;

				if (test[1] < center[1] - this.height / 2)
					test[1] = center[1] - this.height / 2;
				else if (test[1] > center[1] + this.height / 2)
					test[1] = center[1] + this.height / 2;

				if (test[2] < center[2] - this.depth / 2)
					test[2] = center[2] - this.depth / 2;
				else if (test[2] > center[2] + this.depth / 2)
					test[2] = center[2] + this.depth / 2;

				// get distance from closest edges
				return VMath.distance(center, test);
			}
			getNormal(point) {
				var center = this.gameobject.transform.loc;
				var test = [...point];

				if (test[0] < center[0] - this.width / 2)
					return [-1, 0, 0]
				else if (test[0] > center[0] + this.width / 2)
					return [1, 0, 0]

				if (test[1] < center[1] - this.height / 2)
					return [0, -1, 0]
				else if (test[1] > center[1] + this.height / 2)
					return [0, 1, 0]

				if (test[2] < center[2] - this.depth / 2)
					return [0, 0, -1]
				else if (test[2] > center[2] + this.depth / 2)
					return [0, 0, 1]

				return [0, 0, 0];
			}
		}

		class VMath {
			static multiply(vector, scalar) {
				return [vector[0] * scalar, vector[1] * scalar, vector[2] * scalar]
			}
			static divide(vector, scalar) {
				return this.multiply(vector, 1.0 / scalar);
			}
			static add(vector1, vector2) {
				return [vector1[0] + vector2[0], vector1[1] + vector2[1], vector1[2] + vector2[2]]
			}
			static subtract(vector1, vector2) {
				return [vector1[0] - vector2[0], vector1[1] - vector2[1], vector1[2] - vector2[2]]
			}
			static magnitude(vector) {
				return Math.sqrt(Math.pow(vector[0], 2) + Math.pow(vector[1], 2) + Math.pow(vector[2], 2));
			}
			static project(vector1, vector2) {
				return VMath.multiply(vector2, VMath.dot(vector1, vector2));
			}
			static normalize(vector) {
				if (this.magnitude(vector) < 0.0000001) return vector;
				return this.divide(vector, this.magnitude(vector));
			}
			static dot(vector1, vector2) {
				return vector1[0] * vector2[0] + vector1[1] * vector2[1] + vector1[2] * vector2[2];
			}
			static distance(point1, point2) {
				var difference = this.subtract(point1, point2);
				return this.magnitude(difference);
			}
		}

		class Camera extends GameObject {
			constructor() {
				super();
				this.aspect = 1
				this.fov = 70;
				this.nearPlane = 0.25;
				this.farPlane = 500;
			}

			moveCamera(program) {
				var cameraTranLoc = gl.getUniformLocation(program, 'u_cameraTran');
				gl.uniform3fv(cameraTranLoc, new Float32Array(this.transform.loc));
				var cameraRotLoc = gl.getUniformLocation(program, 'u_cameraRot');
				gl.uniform3fv(cameraRotLoc, new Float32Array(this.transform.rot));

				var viewFOVLoc = gl.getUniformLocation(program, 'u_viewFOV');
				gl.uniform1f(viewFOVLoc, this.fov);
				var viewAspectLoc = gl.getUniformLocation(program, 'u_viewAspect');
				gl.uniform1f(viewAspectLoc, this.aspect);

				var viewNearLoc = gl.getUniformLocation(program, 'u_viewNear');
				gl.uniform1f(viewNearLoc, this.nearPlane);
				var viewFarLoc = gl.getUniformLocation(program, 'u_viewFar');
				gl.uniform1f(viewFarLoc, this.farPlane);
			}
		}

		class Light extends GameObject {
			static lights = []
			constructor() {
				super();
				this.type = 0;
				this.color = [1, 1, 1];
				this.range = 64;
				this.type = 0;
				this.angle = 45;

				this.renderShape = new RenderBillboard(this);
				this.renderShape.lightStrength = 0;
				this.renderShape.fogStrength = 0;
				this.renderShape.clipThreshold = 1;
				this.renderShape.transparent = true;
				this.renderShape.loadTexture("imgs/glare.png");

				Light.lights.push(this);
			}
			update(delta, time) {
				super.update(delta, time);

				if (this.renderShape) {
					this.renderShape.color = VMath.multiply(this.color, 2).concat(1);
					this.transform.loc[1] = Math.sin(time * Math.PI * 1.5 + this.transform.loc[0] + this.transform.loc[2]) * 0.25 + 6;
				}
			}
		}

		class Floor extends GameObject {
			constructor() {
				super()

				this.renderShape = new RenderShape(this)
				this.renderShape.fromOBJ(document.getElementById('floorOBJ').text)
				this.renderShape.loadTexture("imgs/TILES01.png");

				this.renderShape.uvScale = [250, 250]
			}
		}

		class Tile extends GameObject {
			constructor() {
				super()
				this.collisionShape = new CollisionCube(this, 4, 4, 4)
				this.collisionShape.solid = true;

				this.renderShape = new RenderShape(this)
				this.renderShape.fromOBJ(document.getElementById('cubeOBJ').text)
				this.renderShape.loadTexture("imgs/textures.png");
			}
		}

		class Bricks extends Tile {
			constructor() {
				super()

				this.renderShape.uvOffset = [-0.5, 0]
			}
			hit(damage) {
				mainInstance.destroyObject(this.id)
				mainInstance.createObject(Explosion, [...this.transform.loc], [0, 0, 0], [4, 4, 4])
			}
		}

		class Moon extends GameObject {
			constructor() {
				super();

				this.renderShape = new RenderBillboard(this);
				this.renderShape.lightStrength = 0;
				this.renderShape.fogStrength = 0;
				this.renderShape.loadTexture("imgs/moon.png");

				this.renderShape.color = [0, 0, 0, 1]
			}
		}

		class Star extends GameObject {
			constructor() {
				super();

				this.renderShape = new RenderBillboard(this);
				this.renderShape.lightStrength = 0;
				this.renderShape.fogStrength = 0;
				this.renderShape.loadTexture("imgs/glare.png");

				this.renderShape.color = [0, 0, 0, 1]
			}
		}

		class Explosion extends GameObject {
			constructor() {
				super();

				this.renderShape = new RenderBillboard(this);
				this.renderShape.lightStrength = 0;
				this.renderShape.fogStrength = 0;
				this.renderShape.loadTexture("imgs/glare.png");

			}
			update(delta, time) {
				super.update(delta, time)
				var scale = delta / 0.125;
				this.transform.scale = VMath.subtract(this.transform.scale, [scale, scale, scale])
				if (this.transform.scale[0] < 0) {
					mainInstance.destroyObject(this.id)
				}
			}
		}

		class Projectile extends GameObject {
			constructor() {
				super();
				this.collisionShape = new CollisionSphere(this, 2);

				this.damage = 1;

				this.hitTypes = [Tile, Bricks]

				this.renderShape = new RenderBillboard(this);
				this.renderShape.lightStrength = 0;
				this.renderShape.fogStrength = 0;
				this.renderShape.loadTexture("imgs/glare.png");
			}
			update(delta, time) {
				super.update(delta, time);
				mainInstance.Objects.forEach(gameObj => {
					if (gameObj == this || gameObj.collisionShape == null) return
					var collisionDistance = mainInstance.checkCollision(this, gameObj)

					if (collisionDistance <= 0 && this.hitTypes.includes(gameObj.className)) {
						if (gameObj.hit) {
							gameObj.hit(this.damage, this.transform.loc)
						}
						var normal = gameObj.collisionShape.getNormal(this.transform.loc, gameObj.transform.loc)
						console.log(normal);
						mainInstance.createObject(Explosion, VMath.add([...this.transform.loc], VMath.multiply(normal, 0.25)))
						mainInstance.destroyObject(this.id);
					}
				});
			}
		}

		class Pickup extends GameObject {
			constructor() {
				super();
				this.collisionShape = new CollisionSphere(this, 0.5);
			}
			update(delta, time) {
				super.update(delta, time);

				mainInstance.Objects.forEach(gameObj => {
					if (gameObj == this || gameObj.collisionShape == null) return
					var collisionDistance = mainInstance.checkCollision(this, gameObj)

					if (collisionDistance <= 0 && gameObj == mainInstance.player) {
						this.onPickUp(gameObj);
					}
				});
			}
			onPickUp(player) {
				mainInstance.destroyObject(this.id);
			}
		}

		class Health extends Pickup {
			constructor() {
				super();
				this.renderShape = new RenderBillboard(this);
				this.renderShape.loadTexture("imgs/health.png");
			}
			onPickUp(player) {
				player.heal(5)
				super.onPickUp()
			}
		}

		class LevelExit extends Pickup {
			constructor() {
				super();
				this.renderShape = new RenderBillboard(this);
				this.renderShape.loadTexture("imgs/exit.png");
			}
			onPickUp(player) {
				super.onPickUp()
				mainInstance.startLevel(mainInstance.currentLevel + 1)
			}
		}

		class Ammo extends Pickup {
			constructor() {
				super();
				this.renderShape = new RenderBillboard(this);
				this.renderShape.loadTexture("imgs/ammo.png");
			}
			onPickUp(player) {
				player.ammo += 12
				super.onPickUp()
			}
		}

		class Bullet extends Projectile {
			constructor() {
				super();
				this.renderShape.color = [0, 1, 1, 1]
				this.hitTypes.push(Roller)
				this.hitTypes.push(Chaser)
				this.hitTypes.push(Caster)
			}
		}

		class Spell extends Projectile {
			constructor() {
				super();
				this.renderShape.color = [1, 0, 0, 1]
				this.hitTypes.push(Player)
			}
		}

		class Entity extends GameObject {
			constructor() {
				super();
				this.collisionShape = new CollisionSphere(this, 1);

				this.maxHealth = 4
				this.health = 4
				this.speed = 256
				this.steps = 0;
			}
			heal(health) {
				this.health = Math.min(this.health + health, this.maxHealth)
			}
			hit(damage, location) {
				this.health = Math.max(this.health - damage, 0)
				if (this.health == 0) this.die()

				var difference = VMath.subtract(this.transform.loc, location)
				this.velocity = VMath.add(this.velocity, VMath.multiply(difference, damage * 8))
			}
			die() {
				mainInstance.destroyObject(this.id)
				mainInstance.createObject(Explosion, [...this.transform.loc], [0, 0, 0], [4, 4, 4])
			}
			solidCollide() {
				mainInstance.Objects.forEach(gameObj => {
					if (gameObj == this || gameObj.collisionShape == null || !gameObj.collisionShape.solid) return
					var collisionDistance = mainInstance.checkCollision(this, gameObj)

					if (collisionDistance <= 0) {
						var normal = gameObj.collisionShape.getNormal(this.transform.loc, gameObj.transform.loc)
						this.transform.setLocation(VMath.subtract(this.transform.loc, VMath.multiply(normal, collisionDistance)))

						this.velocity = VMath.subtract(this.velocity, VMath.project(this.velocity, normal))
					}
				});
			}
		}

		function lerp(v1, v2, t) {
			return (v1 * (1 - t)) + (v2 * t);
		}

		class Enemy extends Entity {
			constructor() {
				super();
				this.collisionShape = new CollisionSphere(this, 0.5);
				this.collisionShape.solid = true;
			}
			damagePlayer(damage) {
				mainInstance.Objects.forEach(gameObj => {
					if (gameObj == this || gameObj.collisionShape == null) return
					var collisionDistance = mainInstance.checkCollision(this, gameObj)

					if (collisionDistance <= 0 && gameObj == mainInstance.player) {

						this.hit(1, gameObj.transform.loc)

						gameObj.hit(damage, this.transform.loc)
					}
				});
			}
		}
		class Roller extends Enemy {
			constructor() {
				super();

				this.renderShape = new AnimatedBillboard(this);
				this.renderShape.loadTexture("imgs/flower.png");

				this.health = 2

				this.renderShape.frameRowCol = [3, 2]
				this.velocity = [4, 0, 0]
			}

			update(delta, time) {
				super.update(delta, time);

				this.renderShape.frame = time * 12 % (5)

				this.damagePlayer(1)

				mainInstance.Objects.forEach(gameObj => {
					if (gameObj == this || gameObj.collisionShape == null) return
					var collisionDistance = mainInstance.checkCollision(this, gameObj)

					if (collisionDistance <= 0) {

						var normal = gameObj.collisionShape.getNormal(this.transform.loc, gameObj.transform.loc)
						this.transform.setLocation(VMath.subtract(this.transform.loc, VMath.multiply(normal, collisionDistance * 2)))

						this.velocity = VMath.subtract(this.velocity, VMath.multiply(VMath.project(this.velocity, normal), 2))
					}
				});
			}
		}

		class Chaser extends Enemy {
			constructor() {
				super();

				this.renderShape = new AnimatedBillboard(this);
				this.renderShape.loadTexture("imgs/enemy1.png");

				this.renderShape.frameRowCol = [3, 3]
			}
			update(delta, time) {
				super.update(delta, time);

				this.renderShape.frame = time * 12 % (this.renderShape.frameRowCol[0] * this.renderShape.frameRowCol[1])

				var dif = VMath.subtract(mainInstance.player.transform.loc, this.transform.loc)

				this.velocity = VMath.add(this.velocity, VMath.multiply(VMath.normalize(dif), 0.5));

				this.velocity = VMath.add(this.velocity, VMath.multiply(this.velocity, -delta * 4))

				this.damagePlayer(2)
				this.solidCollide()
			}
		}

		class Caster extends Enemy {
			constructor() {
				super();

				this.renderShape = new AnimatedBillboard(this);
				this.renderShape.loadTexture("imgs/ghost.png");

				this.health = 6

				this.renderShape.frameRowCol = [4, 4]
				this.firing = false;
			}
			update(delta, time) {
				super.update(delta, time);

				this.renderShape.frame = Math.floor(time * 12 % (13))

				console.log(this.renderShape.frame)

				this.damagePlayer(2)
				this.solidCollide()

				var frame = Math.floor(this.renderShape.frame);

				if (frame == 11 && !this.firing) {
					this.fire();
					console.log(this.firing);
					this.firing = true;
				}
				else if (frame != 11) {
					this.firing = false;
				}
			}
			fire() {
				var firePosition = VMath.add([...this.transform.loc], VMath.multiply(this.transform.forward, -1))
				var bullet = mainInstance.createObject(Spell, firePosition, [0, 0, 0], [1 / 2, 1 / 2, 1 / 2])

				bullet.velocity = VMath.multiply(VMath.multiply(this.transform.forward, -1), 16);
			}
		}

		class Player extends Entity {
			constructor() {
				super();

				this.maxHealth = 8
				this.health = 8

				this.ammo = 24
				this.loaded = 6

				this.camera = null;

				this.speed = 256
				this.steps = 0;

				this.frame = 0;

				this.camera = mainInstance.mainCamera;

				this.loops = [
					[0, 'stay'],
					[1, 2, 3, 4, 5, 6, 'return', 0],
					[7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 'return', 0],
					[28, 29, 30, 31, 32, 'return', 4],
					[33, 'stay'],
					[33, 32, 31, 30, 29, 28, 'return', 0],
					[31, 31, 32, 32, 'return', 4]
				]
				this.loop = 0
				this.loopFrame = 0

				this.frameRate = 24

				this.regularFov = 70
				this.zoomFov = 15
				this.zoom = 0
				this.zoomSpeed = 8
			}

			update(delta, time) {
				super.update(delta, time);
				var move = 0;
				var strafe = 0;
				var rotateX = 0;

				if (mainInstance.isCodePressed(37)) {
					rotateX += -1;
				}
				if (mainInstance.isCodePressed(39)) {
					rotateX += 1;
				}

				if (mainInstance.isKeyPressed('A')) {
					strafe += -1;
				}
				if (mainInstance.isKeyPressed('D')) {
					strafe += 1;
				}

				if (mainInstance.isKeyPressed('S')) {
					move += -1;
				}
				if (mainInstance.isKeyPressed('W')) {
					move += 1;
				}

				if (mainInstance.isKeyPressed('F') && this.loaded > 0 && (this.loop == 0 || this.loop == 4)) {
					this.fire()
				}
				if (mainInstance.isKeyPressed('R') && this.loop == 0) {
					this.reload()
				}
				if (mainInstance.isCodePressed(16)) {
					this.moveZoom(1, this.zoomSpeed * delta)
					if (this.loop == 0) {
						this.playLoop(3)
					}
				}
				else {
					this.moveZoom(0, this.zoomSpeed * delta)
					if (this.loop == 4) {
						this.playLoop(5)
					}
				}

				var normalized = VMath.normalize(VMath.add([strafe, 0, 0], [0, 0, move]))

				this.steps += Math.min(1, VMath.magnitude(normalized) + Math.abs(rotateX)) * delta;

				this.velocity = VMath.add(this.velocity, VMath.multiply(this.transform.forward, delta * this.speed * normalized[2]))
				this.velocity = VMath.add(this.velocity, VMath.multiply(this.transform.right, delta * this.speed * normalized[0]))

				this.angVelocity = VMath.add(this.angVelocity, VMath.multiply([0, rotateX, 0], delta * (3 - (this.zoom * 2)) * 3 * Math.PI))

				this.velocity = VMath.add(this.velocity, VMath.multiply(this.velocity, -delta * 16))

				this.angVelocity = VMath.add(this.angVelocity, VMath.multiply(this.angVelocity, -delta * 10))

				this.transform.loc[1] = 1

				this.solidCollide();

				var bobbing = VMath.multiply(this.transform.up, Math.sin(this.steps * 15) * 0.125)

				this.camera.transform.setLocation(VMath.add(this.transform.loc, bobbing));
				this.camera.transform.setRotation(this.transform.rot);

				var loop = this.loops[this.loop]
				var loopValue = loop[Math.floor(this.loopFrame)]
				this.frame = loopValue
				this.loopFrame = (this.loopFrame + delta * this.frameRate) % loop.length

				loopValue = loop[Math.floor(this.loopFrame)]
				if (loopValue == 'return') {
					this.playLoop(loop[Math.floor(this.loopFrame) + 1])
				}
				else if (loopValue == 'stay') {
					this.loopFrame -= 1
				}
			}
			moveZoom(zoom, speed) {
				var difference = this.zoom - zoom;
				this.zoom = this.zoom - difference * speed;
				this.camera.fov = lerp(this.regularFov, this.zoomFov, this.zoom);
			}
			playLoop(index) {
				this.loopFrame = this.loopFrame % 1
				this.loop = index;
			}
			fire() {
				if (this.loop == 0)
					this.playLoop(1)
				if (this.loop == 4)
					this.playLoop(6)
				this.loaded -= 1
				var firePosition = VMath.add([...this.transform.loc], VMath.multiply(this.transform.forward, 1))
				var bullet = mainInstance.createObject(Bullet, firePosition, [0, 0, 0], [1 / 8, 1 / 8, 1 / 8])

				bullet.velocity = VMath.multiply(this.transform.forward, 24);
			}
			reload() {
				var toLoad = Math.min(this.ammo, 6)
				this.ammo -= toLoad;
				this.loaded = toLoad;
				if (toLoad > 0)
					this.playLoop(2)
			}
			die() {
				super.die()
				mainInstance.player = null;
				mainInstance.restartLevel()
			}
		}
	</script>

	<script>

		class InitWebGLProgram {
			constructor() {
				gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

				//gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
				gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
				gl.enable(gl.BLEND);

				gl.clearColor(1, 1, 1, 1);
				gl.enable(gl.DEPTH_TEST);
				gl.enable(gl.CULL_FACE);
				gl.depthMask(true);
				gl.cullFace(gl.FRONT);
			}
			createShader(type, source) {
				var shader = gl.createShader(type);
				gl.shaderSource(shader, source);
				gl.compileShader(shader);

				var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
				if (success) {
					return shader;
				}

				console.error(gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
			}

			createProgram(vs, fs) {
				var program = gl.createProgram();
				gl.attachShader(program, vs);
				gl.attachShader(program, fs);
				gl.linkProgram(program);
				var success = gl.getProgramParameter(program, gl.LINK_STATUS);
				if (success) {
					return program;
				}

				console.error(gl.getProgramInfoLog(program));
				gl.deleteProgram(program);
			}
		}

		class MapGenerator {
			static Generate(tiles, width, height) {
				for (let i = 0; i < tiles.length; i++) {
					const tile = tiles[i]
					var x = i % width
					var y = Math.floor(i / width)

					var location = [(x - width / 2) * 4, 1, (y - height / 2) * 4]

					if (tile == 1)
						mainInstance.createObject(Tile, location, [0, 0, 0], [2, 2, 2])

					if (tile == 2)
						mainInstance.createObject(Bricks, location, [0, 0, 0], [2, 2, 2])

					if (tile == 3)
						mainInstance.createObject(Health, location, [0, 0, 0]);

					if (tile == 4)
						mainInstance.createObject(Ammo, location, [0, 0, 0]);

					if (tile == 6)
						mainInstance.createObject(Chaser, location, [0, 0, 0], [2, 2, 2]);

					if (tile == 5)
						mainInstance.createObject(Roller, location, [0, 0, 0], [2, 2, 2]);

					if (tile == 7)
						mainInstance.createObject(Caster, location, [0, 0, 0], [2, 2, 2]);

					if (tile == 8)
						mainInstance.createObject(LevelExit, location, [0, 0, 0], [2, 2, 2]);

					if (tile == 9)
						mainInstance.player.transform.setLocation(location);
				}
			}
		}

		class Main {
			constructor() {
				mainInstance = this;

				this.webGL = new InitWebGLProgram();
				var vertexShaderSource = document.getElementById("2dVertexShader").text;
				var fragmentShaderSource = document.getElementById("2dFragmentShader").text;
				var vertexShader = this.webGL.createShader(gl.VERTEX_SHADER, vertexShaderSource);
				var fragmentShader = this.webGL.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
				this.program = this.webGL.createProgram(vertexShader, fragmentShader);
				gl.useProgram(this.program);

				this.lastTime = 0;

				this.currentLevel = 0

				this.levels = [
					[
						1, 1, 1, 1, 1, 1,
						1, 0, 9, 0, 0, 1,
						1, 0, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 1,
						1, 0, 4, 4, 0, 1,
						1, 0, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 1,
						1, 0, 0, 8, 0, 1,
						1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1,
						1, 0, 9, 0, 0, 1,
						1, 4, 0, 0, 0, 1,
						1, 0, 0, 0, 5, 1,
						1, 0, 0, 0, 0, 1,
						1, 2, 2, 1, 1, 1,
						1, 0, 0, 0, 0, 1,
						1, 3, 0, 0, 8, 1,
						1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
						1, 0, 9, 0, 2, 0, 0, 0, 0, 1,
						1, 0, 0, 4, 2, 0, 0, 0, 0, 1,
						1, 0, 0, 0, 2, 0, 0, 0, 0, 1,
						1, 2, 2, 2, 2, 0, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 0, 6, 0, 0, 1,
						1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
						1, 0, 0, 6, 0, 0, 0, 0, 0, 1,
						1, 3, 1, 0, 1, 1, 4, 1, 8, 1,
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
						1, 0, 9, 0, 2, 0, 0, 0, 0, 1,
						1, 4, 0, 0, 2, 0, 0, 6, 0, 1,
						1, 0, 0, 0, 2, 0, 0, 0, 5, 1,
						1, 2, 2, 2, 2, 0, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 0, 6, 0, 4, 1,
						1, 0, 0, 0, 0, 0, 0, 0, 5, 1,
						1, 6, 0, 6, 0, 0, 0, 0, 0, 1,
						1, 3, 1, 0, 1, 1, 4, 1, 8, 1,
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
						1, 0, 9, 0, 0, 1, 0, 0, 0, 0,
						1, 4, 0, 0, 0, 1, 0, 0, 0, 0,
						1, 0, 0, 0, 5, 1, 0, 0, 0, 0,
						1, 2, 2, 2, 2, 1, 1, 1, 1, 1,
						1, 0, 0, 0, 0, 2, 0, 6, 8, 1,
						1, 0, 0, 0, 0, 2, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 2, 0, 0, 0, 1,
						1, 0, 0, 7, 0, 2, 0, 0, 7, 1,
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
						1, 0, 9, 0, 0, 1, 0, 0, 0, 0,
						1, 0, 0, 0, 0, 1, 0, 0, 0, 0,
						1, 4, 0, 0, 5, 1, 0, 0, 0, 0,
						1, 0, 0, 0, 0, 1, 1, 1, 1, 1,
						1, 0, 0, 0, 0, 2, 3, 6, 3, 1,
						1, 5, 0, 0, 0, 2, 0, 0, 0, 1,
						1, 0, 0, 0, 0, 2, 0, 0, 6, 1,
						1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
						1, 2, 4, 2, 2, 0, 0, 0, 0, 1,
						1, 4, 0, 2, 0, 2, 0, 2, 0, 1,
						1, 7, 2, 0, 0, 0, 2, 6, 0, 1,
						1, 2, 2, 2, 1, 1, 1, 1, 1, 1,
						1, 0, 0, 0, 0, 0, 0, 5, 3, 1,
						1, 0, 5, 0, 6, 0, 0, 4, 6, 1,
						1, 6, 0, 0, 0, 6, 0, 5, 3, 1,
						1, 1, 1, 1, 1, 1, 1, 2, 2, 1,
						1, 7, 2, 0, 0, 0, 2, 0, 0, 1,
						1, 8, 0, 7, 2, 0, 0, 0, 0, 1,
						1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
					],
					[
						1, 1, 1, 1, 1, 1,
						1, 9, 0, 0, 4, 1,
						1, 0, 0, 0, 4, 1,
						1, 0, 0, 3, 4, 1,
						1, 0, 3, 3, 4, 1,
						1, 4, 4, 4, 4, 1,
						1, 1, 1, 1, 1, 1,
					],
				]

				this.levelDims = [[6, 9], [6, 9], [10, 9], [10, 9], [10, 9], [10, 20], [6, 6]]


				this.startLevel(this.currentLevel)

				this.Keys = [];

				var fpsImage = new Image()
				fpsImage.crossOrigin = 'anonymous'
				fpsImage.src = "imgs/fps.png"

				this.fpsimage = fpsImage;
			}

			restartLevel() {
				this.startLevel(this.currentLevel)
			}

			startLevel(index) {
				this.currentLevel = index;

				this.ObjectCounter = 0;

				this.Objects = [];

				this.mainCamera = this.createObject(Camera, [0, 8, 3], [75 * Math.PI / 180, Math.PI, 0])
				this.mainCamera.fov = 70;

				var newPlayer = this.createObject(Player, [0, 0, 0]);

				if (this.player) {
					newPlayer.health = this.player.health;
					newPlayer.ammo = this.player.ammo;
					newPlayer.loaded = this.player.loaded;
				}

				this.player = newPlayer

				console.log(this.player)

				this.createEnvironment();

				MapGenerator.Generate(this.levels[index], this.levelDims[index][0], this.levelDims[index][1])
			}

			createEnvironment() {
				this.createObject(Floor, [0, -1, 0])

				for (let i = 0; i < 8; i++) {
					var loc = [Math.random() * 50 - 10, 4, Math.random() * 50 - 25]
					var light = this.createObject(Light, loc);
					light.color = [Math.random(), Math.random(), Math.random()];
					light.range = 16;
				}

				for (let i = 0; i < 128; i++) {
					var yAngle = Math.random() * 2 * Math.PI;
					var xAngle = Math.random() * Math.PI;

					var loc = [Math.sin(yAngle) * 200, Math.sin(xAngle) * 200, Math.cos(yAngle) * 200]

					var scalar = Math.random() * 2 + 1;
					var scale = [scalar, scalar, scalar]

					this.createObject(Star, loc, [0, 0, 0], scale);
				}

				this.createObject(Moon, [200, 150, 200], [0, 0, 0], [50, 50, 50])
			}

			updateAll(delta) {
				this.Objects.forEach(gameObj => {
					gameObj.update(delta, mainInstance.lastTime);
				});
			}

			renderAll() {

				gl.clear(gl.COLOR_BUFFER_BIT);

				this.setMainLight(this.program, [1, 1, 1], [0.125, 0.125, 0.125])

				this.setAmbientLight(this.program, [0.5, 0.5, 0.5])

				this.setLightUniforms(this.program);

				this.setCameraUniforms(this.program);

				this.setFog(this.program, [1, 1, 1])

				var transparents = [];

				this.Objects.forEach(gameObj => {
					if (gameObj.renderShape != null) {
						if (gameObj.renderShape.transparent) {
							transparents.push(gameObj);
						}
						else {
							gameObj.renderShape.render(this.program);
						}
					}
				});

				gl.depthMask(false);

				transparents.forEach(gameObj => {
					gameObj.renderShape.render(this.program);
				});

				gl.depthMask(true);

				this.drawHud()
			}

			drawHud() {
				ctx2d.clearRect(0, 0, canvas.width, canvas.height)

				this.fpsFrame = Math.floor(this.lastTime * 12 % 30)

				ctx2d.font = "32px serif";
				ctx2d.fillStyle = "grey"
				ctx2d.fillText(`HEALTH: ${this.player.health} / ${this.player.maxHealth}`, 16 + 2, 32 + 2);
				ctx2d.fillStyle = "#cf0053"
				ctx2d.fillText(`HEALTH: ${this.player.health} / ${this.player.maxHealth}`, 16, 32);

				ctx2d.font = "32px serif";
				ctx2d.fillStyle = "grey"
				ctx2d.fillText(`AMMO: ${this.player.ammo}`, 16 + 2, 64 + 2);
				ctx2d.fillStyle = "#3c3b57"
				ctx2d.fillText(`AMMO: ${this.player.ammo}`, 16, 64);

				ctx2d.font = "32px serif";
				ctx2d.fillStyle = "grey"
				ctx2d.fillText(`LOADED: ${this.player.loaded} / 6`, 16 + 2, 96 + 2);
				ctx2d.fillStyle = "#1e19b0"
				ctx2d.fillText(`LOADED: ${this.player.loaded} / 6`, 16, 96);

				var reticleSize = 4

				ctx2d.fillStyle = "white"
				ctx2d.fillRect(canvas.width / 2 - reticleSize / 2, canvas.height / 2 - reticleSize / 2, reticleSize, reticleSize)
				ctx2d.fillStyle = "black"
				ctx2d.rect(canvas.width / 2 - reticleSize / 2, canvas.height / 2 - reticleSize / 2, reticleSize, reticleSize)
				ctx2d.stroke()

				if(this.currentLevel == this.levels.length - 1){
					ctx2d.font = "64px serif";
					ctx2d.fillStyle = "grey"
					ctx2d.fillText(`YOU WIN`, canvas.width/2 - 160 + 2, canvas.height/2 + 16 + 2);
					ctx2d.fillStyle = "white"
					ctx2d.fillText(`YOU WIN`, canvas.width/2 - 160, canvas.height/2 + 16);
				}

				var spriteSize = 256
				var indexWidth = 6

				var imageXPos = (this.player.frame % indexWidth) * spriteSize;
				var imageYPos = Math.floor(this.player.frame / indexWidth) * spriteSize;

				var fpsSize = 512
				var fpsYPos = canvas.height - fpsSize + 32 + (Math.cos(this.player.steps * 15) + 1) * 16

				var fpsXPos = lerp(canvas.width - fpsSize, canvas.width / 2 - fpsSize / 2, this.player.zoom)

				ctx2d.drawImage(this.fpsimage, imageXPos, imageYPos, spriteSize, spriteSize, fpsXPos, fpsYPos, fpsSize, fpsSize)
			}

			setLightUniforms(program) {
				var lightRanges = []
				var lightAngles = []
				var lightTypes = []

				var lightColors = []
				var lightPositions = []
				var lightDirections = []

				Light.lights.forEach(light => {
					lightRanges.push(light.range);
					lightAngles.push(light.angle);
					lightTypes.push(light.type);

					lightPositions = lightPositions.concat(light.transform.loc);
					lightColors = lightColors.concat(light.color);
					lightDirections = lightDirections.concat([light.transform.forward[0], light.transform.forward[1], light.transform.forward[2]]);
				});

				var lightRangeLoc = gl.getUniformLocation(program, 'u_lightRange');
				gl.uniform1fv(lightRangeLoc, new Float32Array(lightRanges));
				var lightAngleLoc = gl.getUniformLocation(program, 'u_lightAngle');
				gl.uniform1fv(lightAngleLoc, new Float32Array(lightAngles));
				var lightTypeLoc = gl.getUniformLocation(program, 'u_lightType');
				gl.uniform1iv(lightTypeLoc, new Int8Array(lightTypes));

				var lightPosLoc = gl.getUniformLocation(program, 'u_lightPos');
				gl.uniform3fv(lightPosLoc, new Float32Array(lightPositions));
				var lightColorLoc = gl.getUniformLocation(program, 'u_lightColor');
				gl.uniform3fv(lightColorLoc, new Float32Array(lightColors));
				var lightDirLoc = gl.getUniformLocation(program, 'u_lightDir');
				gl.uniform3fv(lightDirLoc, new Float32Array(lightDirections));
			}

			setMainLight(program, direction, color) {
				var mainLightDirLoc = gl.getUniformLocation(program, 'u_mainLightDir');
				gl.uniform3fv(mainLightDirLoc, new Float32Array(direction));
				var mainLightColorLoc = gl.getUniformLocation(program, 'u_mainLightColor');
				gl.uniform3fv(mainLightColorLoc, new Float32Array(color));
			}
			setAmbientLight(program, color) {
				var ambientLightColorLoc = gl.getUniformLocation(program, 'u_ambientLightColor');
				gl.uniform3fv(ambientLightColorLoc, new Float32Array(color));
			}

			setFog(program, color) {
				var fogColorLoc = gl.getUniformLocation(program, 'u_fogColor');
				gl.uniform3fv(fogColorLoc, new Float32Array(color));
			}

			setCameraUniforms(program) {
				var viewFOVLoc = gl.getUniformLocation(program, 'u_viewFOV');
				gl.uniform1f(viewFOVLoc, this.fov);
				var viewAspectLoc = gl.getUniformLocation(program, 'u_viewAspect');
				gl.uniform1f(viewAspectLoc, this.aspect);

				this.mainCamera.aspect = canvas.width / canvas.height
				this.mainCamera.moveCamera(program);
			}

			checkCollision(gameObject1, gameObject2) {
				var shape1 = gameObject1.collisionShape;
				var shape2 = gameObject2.collisionShape;

				var loc1 = gameObject1.transform.loc;
				var loc2 = gameObject2.transform.loc;

				if (shape1 == null || shape2 == null) {
					return Number.MAX_VALUE;
				}

				var overlap = VMath.distance(loc1, loc2) - (shape1.getDistance(loc2) + shape2.getDistance(loc1));
				return overlap;
			}

			createObject(className, loc = [0, 0, 0], rot = [0, 0, 0], scale = [1, 1, 1]) {
				var temp = new className

				var id = this.ObjectCounter;
				this.ObjectCounter++;

				temp.id = id;
				temp.className = className;
				temp.transform.setLocation(loc);
				temp.transform.setRotation(rot);
				temp.transform.scale = scale;

				this.Objects[id] = temp;
				return temp;
			}

			destroyObject(id) {
				if (id in this.Objects) {
					delete this.Objects[id];
					return true;
				}
				return false;
			}

			isKeyPressed(key) {
				var code = key.charCodeAt(0);
				if (code in this.Keys) {
					return this.Keys[code];
				}
				return false;
			}

			isCodePressed(code) {
				if (code in this.Keys) {
					return this.Keys[code];
				}
				return false;
			}

			keyDown(event) {
				this.Keys[event.keyCode] = true;
			}

			keyUp(event) {
				this.Keys[event.keyCode] = false;
			}

			mouseClick(event) {
				var coord = Main.webGLPosition(event.clientX, event.clientY);
				console.log("The click occurred on " + coord.x + "," + coord.y);
			}

			//Static call backs

			static keyD(event) {
				mainInstance.keyDown(event);
			}

			static keyU(event) {
				mainInstance.keyUp(event);
			}

			static mouseC(event) {
				mainInstance.mouseClick(event);
			}

			static mainLoop(timestamp) {
				timestamp /= 1000;
				var delta = timestamp - mainInstance.lastTime
				delta = Math.min(delta, 0.125);

				mainInstance.lastTime = timestamp;

				mainInstance.updateAll(delta);
				mainInstance.renderAll();

				requestAnimationFrame(Main.mainLoop);
			}

			static webGLPosition(clientX, clientY) {
				// convert coordinates from pixel to webGL
				var rect = canvas.getBoundingClientRect(); // get the rect of the canvas
				var realX = clientX - rect.left; // the X pos on the page, offset by the canvas bounds
				var realY = clientY - rect.top // the Y pos on the page, offset by the canvas bounds
				var x = -1 + 2 * realX / canvas.width; // the webGL-adjusted X, between -1 and 1
				var y = -1 + 2 * (canvas.height - realY) / canvas.height; // the webGL-adjusted Y, between -1 and 1, with the y-axis inverted

				return { x, y }
			}
		}

	</script>

</Head>

<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: content-box;
	}

	.fullscreen {
		position: fixed;
		top: 0;
		right: 0;
		bottom: 0;
		left: 0;
		display: flex;
		justify-content: center;
		align-items: center;
	}

	canvas {
		position: absolute;
	}
</style>

<BODY style="padding: 15px; background-color: black;">
	<HEADER>

	</HEADER>

	<div class="fullscreen">
		<CANVAS id="myCanvas" width="960" height="720"
			style="background-color: white; border: 4px inset; border-color: gray;">
			Your browser does not support canvas.
		</CANVAS>
		<CANVAS id="textCanvas" width="960" height="720">
			Your browser does not support canvas.
		</CANVAS>
	</div>

	<SCRIPT>
		var canvas = document.getElementById("myCanvas");
		var gl = canvas.getContext("webgl");
		var ctx2d = document.getElementById("textCanvas").getContext("2d");
		var mainInstance;
		mainInstance = new Main();

		window.onkeydown = Main.keyD;
		window.onkeyup = Main.keyU;

		canvas.addEventListener("click", Main.mouseC);

		requestAnimationFrame(Main.mainLoop);

	</SCRIPT>

	<FOOTER>

	</FOOTER>


</BODY>

</HTML>
            </main>
        </div>
        <footer>
            <a class="link" href="https://floofinator.itch.io/"><img class="icon" 
                src="/icons/itchio.png">Itch.io</a>
            <a class="link" href="https://ko-fi.com/floofinator"><img class="icon"
                src="/icons/kofi.png">Kofi</a>
            <a class="link" href="patreon.com/floofinator"><img class="icon"
                src="/icons/patreon.png">Kofi</a>
            <a class="link" href="https://bsky.app/profile/floofinator.com"><img class="icon"
                src="/icons/bluesky.png">BlueSky</a>
            <a class="link" href="https://x.com/floofinator7"><img class="icon"
                src="/icons/twitter.png">Twitter</a>
            <a class="link" href="https://www.youtube.com/@floofinator/"><img class="icon"
                src="/icons/youtube.png">Youtube</a>
            <a class="link" href="https://floofinator7.newgrounds.com/"><img class="icon"
                src="/icons/newgrounds.png">Newgrounds</a>
            <a class="link" href="https://floofinator.neocities.org/"><img class="icon"
                src="https://neocities.org/img/cat.png">Neocities</a>
            <a class="link" href="javascript:location='mailto:\u0063\u006f\u006e\u0074\u0061\u0063\u0074\u0040\u0066\u006c\u006f\u006f\u0066\u0069\u006e\u0061\u0074\u006f\u0072\u002e\u0063\u006f\u006d';void 0">
                <img class="icon" src="/icons/mail.png">Send Me an E-mail</a>
            <a class="link" href="/LukeTResume.pdf">
                <img class="icon" src="/icons/document.png">My Resume</a>
        </footer>
    </div>
    <canvas id="background"></canvas>
</body>

</html>